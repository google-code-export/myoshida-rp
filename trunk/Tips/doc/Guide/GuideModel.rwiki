
h1. モデルのスケルトンの生成

MVC のうち、 Model をまず作っていきましょう。
プラグインのスケルトン作成と同様にモデルにもスケルトン作成機能があります。


h2. データベース

モデルはデータベースを扱うものです。ここで簡単にデータベースの説明をしておきます。
データの一つ一つは *レコード* と呼ばれます。チケットでいうと一つのチケットがレコードになります。
データの要素は *カラム* と呼びます。チケットでは「題名」、「トラッカー」、「説明」などがそれにあたります。
このレコードは *テーブル* に格納されます。
データベースはこのテーブルを複数持ちます。 redmine のデータベースではチケットのテーブル、文書テーブルといった複数のテーブルを持っています。この redmine のデータベースの中に今回プラグイン用のテーブルを新たに作成することになります。


h2. モデルの名前とデータ構成を決める

まず、モデルを作成するにはモデルの名前を決めておく必要があります。
[[GuideSampleSpec|サンプルの仕様]] で決めたデータは特に意味のないサンプル的なものにしました。そこでモデルの名前もよくサンプルで使われる *Foo* とします。

次にデータ構成を決める必要があります。すなわちデータがどのようなカラムを持つかということを決めることになります。
データの要素は *題名* と *説明* にしました。まず、データレコードにはこの 2 つのカラムが必要です。
これに加えて要素としては *プロジェクト ID* も必要になります。これはプラグインをプロジェクトごとで使用する場合に必要となります。プロジェクトごとのデータというとプロジェクトのディレクトリのような入れ物の中にデータが格納されるイメージをもたれるかもしれません。しかし、実際には Foo のデータのテーブルは一つで、データの中にどのプロジェクトかという情報をいれたカラムを持たせ、現在のプロジェクトに一致したデータだけを表示するという方法で実現します。

これらのデータのカラムの名前と型を次のようにします。

|_. 要素          |_.  名前     |_. 型           |
| プロジェクト ID | project_id  | 整数(integer)  |
| 題名		  | title       | 文字列(string) |
| 説明		  | description | 文字列(text)	 |

これ以外にも Rails では *id* というカラムを自動的に持ちます。これはデータを識別するための整数型で番号で、ここにはデータをデータベースに追加する際に自動的に番号が割り振られます。
これと同様にプロジェクトも id を持っています。これを格納するのが project_id で、データの属するプロジェクトを表します。
title には *string*、description には *text* の文字列型を使用します。string 型には 256 文字という制限があるため、詳細表示用の description は text にしています。それならば title も text にすればと思われるかもしれませんが、text は string に比べてデータベースの処理速度が遅くなってしまうため、string ですむものは string にしておくべきです。


h2. モデルスケルトンの生成

コントローラのスケルトンの実行コマンドの書式は次のような形です。

<pre>
$ ruby script/generate redmine_plugin_controler プラグイン名 モデル名 カラム名:型 [...]
</pre>

Redmine のトップディレクトリに移動して、決めた名前で実際にコマンドを実行します。

<pre>
$ ruby script/generate redmine_plugin_model Standard Foo project_id:integer title:string description:text
</pre>

実行結果
<pre>
      exists  app/models/
      create  test/unit/
      create  test/fixtures/
      create  app/models/foo.rb
      create  test/unit/foo_test.rb
      create  test/fixtures/foos.yml
      exists  db/migrate
      create  db/migrate/20110612021254_create_foos.rb
</pre>

実行するとモデルの他にテスト用のコードと db/migrate 以下のファイルが作成されます。


h2. 生成された Migration 用のファイル

データを保存できるようにするにはデータベースにテーブルを作る必要があります。これは Migration と呼ばれる処理で行われ、インストールのときデータベースを作成したように rake で実行されます。

このときに使われるのが db/migrate/20110612021254_create_foos.rb です。

<pre><code class="ruby">
class CreateFoos < ActiveRecord::Migration
  def self.up
    create_table :foos do |t|
      t.column :project_id, :integer
      t.column :title, :string
      t.column :description, :text
    end
  end

  def self.down
    drop_table :foos
  end
end
</pre>

Migration 時にテーブルを作成するメソッドと削除するメソッドがそれぞれ定義されています。


h2. Migration の実行

Rails のトップディレクトリで以下のコマンドを実行すると Migration が実行されます。

<pre>
$ rake db:migrate_plugins
</pre>

実行結果
<pre>
  :
Migrating open_id_authentication...
Migrating prepend_engine_views...
Migrating redmine_standard...
==  CreateFoos: migrating =====================================================
-- create_table(:foos)
   -> 0.0030s
==  CreateFoos: migrated (0.0030s) ============================================

Migrating rfpdf...
  :
</pre>

このとき実行されるのは vender/plugins 以下にあるすべてのプラグインです。
各プラグインでは db/migrate 以下にあるファイルを番号の小さいものから順に実行します。生成された Migration 用のファイルは先頭は日付から決められています。つまり日付の古い方から実行されることになります。

この Migration の処理は一度実行したファイルの番号を覚えています。先ほどと同じコマンドをもう一度実行してみてください。 Migration redmine_standard 以下で今度は何もしません。

プラグイン製作中にデータの構成を変更したくなった場合はもう一度 Model のスケルトンの生成をやり直すか、修正してファイルの番号を上げておく必要があります。このとき、すでにテーブルが作成済みの場合エラーとなるので、テーブルを削除しておく必要があります。
プラグインを公開した後などで、データ構成を変更したくなった場合はテーブル作成ファイルよりもファイルの番号が大きく、カラムの追加、削除といった修正内容を記述した Migration 用ファイルを用意します。


h2. 生成された Model のファイル

Model のファイル app/models/foo.rb を見てみましょう.
<pre>
class Foo < ActiveRecord::Base
  unloadable
end
</pre>

2 行目に *unloadable* という見慣れないものがあると思いますが、これはおまじないのようなものだと思ってください。ただ、これを書いておかないと development モードで正常に動作しなくなります。
よく C の入門で使う Hello World のプログラムなどで最初 #include などをおまじないで説明して、後で詳しく説明したりしますが、これはただ書いてあればそれでよいので、おまじないのままでも十分です。詳しく知らないと落ち着かないという方はネットなどで調べてみてください。

後はシンプルです。 ActiveRecord モジュールの Base クラスを継承したクラスで実装されているというだけです。Rails の Model クラスでは親クラスの ActiveRecord::Base がほとんどやってくれるので、基本的にこちらに記述しなければならない内容はありません。

Foo クラスの一つのインスタンスが一つのレコード情報に相当します。データの要素にもカラム名のアクセサメソッドでアクセスできます。 インスタンス名を foo とすると foo.title や foo.description といった感じです。データベースからのデータの取得は Foo::find のようなクラスメソッドで行います。


h2. sqlite3 によるデータベースの操作

基本的に Rails でデータベースの操作を行う場合、 rake で行いますが、先ほど説明したようにプラグイン製作中にデータベースのテーブルを削除したくなることはあります。そこでその方法だけ簡単に説明しておきます。
環境は[[GuideDevEnv|開発環境の準備]]のところで用意したとおりのものとして、sqlite3 の場合について説明します。操作にはコマンドラインで実行する splite3.exe プログラムを使用します。インストールされていない場合はインストールしておいてください。 

h3. データベースを開く

config/database.yml の設定でデータベースファイルを db/redmine.db としました。まず、このファイルをオープンします。

<pre>
$ splite3.exe db/redmine.db
</pre>

実行すると *splite>* のプロンプトになります。ここで操作用のコマンドを実行します。

ヘルプと終了は次のコマンドです。
<pre>
sqlite> .help
sqlite> .quit
</pre>

h3. テーブルの表示と削除

次のコマンドでテーブルの一覧が表示されます。
<pre>
sqlite> .tables
</pre>

そこで削除したいテーブルを探します。ここでは foos がそれにあたります。
そのテーブル名で削除用の SQL 文を実行します。. で始まっているのはコマンドですが、テーブルの削除は SQL 文なので、最後に ; が必要です。
<pre>
sqlite> drop table foos;
</pre>


splite3.exe でデータベースファイルの後に SQL 文を書くことで、コマンドプロンプトに入らずにテーブルを削除することも出来ます。
<pre>
$ splite3.exe db/redmine.db "drop table foos;"
</pre>


h3.  テーブルをもう一度作る

db/migrate のファイルの番号を大きくしてもう一度 rake db:migrate_plugins のコマンドを実行してください。

20110612021254_create_foos.rb
	↓
20110612021255_create_foos.rb




---

| [[プラグイン開発ガイド|^]] | [[GuideInitRb|<<]] | [[GuideControlSkelton|>>]] |
