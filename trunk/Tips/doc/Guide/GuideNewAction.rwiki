h1. 新規作成(new) アクション

新しいページを作成するためのアクションを実装します。
このページは一覧表示ページから呼ばれることになります。


h2. 新規作成ページの仕様

まず、作成する新規作成ページの動きについてもう少し細かく決めておきましょう。
新規作成ページではパラメータを指定して、新しいデータを作成することになります。サンプルでは題名(subject)と説明(decription)です。説明は wiki で記述できるようにします。通常の wiki のように添付ファイルやプレビューまでつけようとすると少し複雑になりますが、 wiki 形式にするだけならば結構簡単です。

!new.png!

チケットでは [作成] ボタンを押すとチケットが作成されて詳細情報のページになります。サンプルでも [作成] 後には詳細説明のページになるようにします。
また、チケットと同様に題名に何も入力されていないとエラーメッセージがでて、データが作成されないようにもします。



h2. GET と POST

コントローラ → View のデータのデータの受け渡しではインスタンス変数を使用することが出来ました。 new では逆に View → コントローラにデータを受け渡す必要があります。Rails ではこの場合 CGI の GET や POST を使ってデータを受け取ることになります。

よく検索サイトや辞書サイトではアドレスの後に ? が付いていろいろとパラメータが設定されていると思います。このようにアドレスにつけてパラメータを渡す方法を *GET* といいます。この方法の利点はアドレスに渡すので、検索条件込みでリンクをつくることができる点です。プラグインを作る場合でもフィルタなどの検索を作ろうとした場合にはパラメータの受け渡しには GET を使った方がいいです。
前章の index での各データへのリンクでは form_id の値もパラメータとして渡していました。これは GET でパラメータを渡すことになります。 Rails では url の指定をハッシュで行った場合、コントロール、アクション、 ID 以外のパラメータはデフォルトでは GET として渡されるためです。

GET ではアドレスとしてパラメータを持たせるため、あまり長いパラメータの場合には不向きですし、 255 文字という制限があります。こういった場合には *POST* を使ってデータを送信することになります。 Rails ではフォームの場合、デフォルトは POST になります。
新規作成ページの場合も POST でデータを送信することになります。

ただし、 Rails では受け取る場合その違いを意識する必要はありません。 GET や POST で受け渡されるデータはキーと値のペアなのですが、これらは params 変数のハッシュの中に格納されます。
つまり、 View → コントローラでデータを受け取る場合には params 変数で行うことになります。

!view_control.png!


h2. コントローラの実装

コントローラ(app/controller/foo_app/controllers/foos_controller.rb) の new メソッドを実装します。 

<pre><code class="ruby">
    @foo = Foo.new(params[:foo])
    @foo.project_id = @project.id

    if request.post? and @foo.save	
      flash[:notice] = l(:notice_successful_create)
      redirect_to :action => 'show', :id => @project, :foo_id => @foo.id
    end
</code></pre>

new アクションは一覧表示からのリンクから呼び出されます。しかし、それだけでなく新規作成画面で [作成] ボタンが押された後、再度 new アクションが実行されることになります。

Foo モデルクラスのオブジェクトを新規作成して、 project_id メンバに現在のプロジェクト(@project) の id を設定しています。
このとき、引数として params の :foo の値が渡されています。一覧表示から呼び出された場合には、この中は空なので、通常のオブジェクトの作成と同じです。

[作成] から呼び出された場合にはここには値が入っています。 :foo をキーとした値の中はさらにハッシュになっていて、そこに :subject や :description をキーとして値が入っています。例えば説明の中身を取り出したい場合は params[:foo][:description] でアクセスすることが出来ます。
Foo.new の引数として、このハッシュを渡すことでメンバにそのハッシュの中身が格納されたオブジェクトが作成されます。

*request.post?* は POST が実行されたかどうかです。そのため、新規作成から呼ばれた場合は偽となり、メソッドを抜け、 new.html.erb が作成表示されます。

[作成] から呼び出された場合、 @foo.save が実行されます。 save はオブジェクトの中身をレコードとしてデータベースに保存する Foo モデルのメンバ関数です。

POST でかつ保存も成功したあとに実行されているコードはチップの作成時にでてくるような"作成されたました"というようなメッセージを出力するためのものです。

最後に *redirect_to* を使い、show アクションに変更しています。これにより新規作成ページではなく、詳細ページが表示されることになります。 redirect_to に渡す引数はリンクなどでのアクション指定の場合と同じものです。


h2. View の実装

次に View (app/views/foos/new.html.erb) を実装します。

<pre><code class="rhtml">
<% labelled_tabular_form_for :foo, @foo, {} do |f| %>
    <%= render :partial => 'foos/form', :locals => {:form => f} %>
    <%= f.submit l(:button_create) %>
<% end %>
</code></pre>


h3. 部分描画

新規作成と編集ページではほぼ同じ画面となります。 同じようなことを何度も書くのは DRY じゃありません
他のプログラミングでは同じような部分があった場合、共通部分を関数として抜き出したりします。 Rails でも同様に共通の描画部分を分けることが出来ます。

それが new.html.erb の 2 行目の render の部分になります。
*":partial=>'foos/form'* で共通部分を記述しているファイルを指定しています。指定は app/views 以下のパスで指定するのですが、実際のファイルは *app/views/foos/_form.index.html.erb* となります。つまり、実際には先頭に _ アンダーバーを付けて、拡張子を付加したものが検索されます。
*:locals* では関数のように引数を指定することが出来ます。ここでは f で指定されたオブジェクトが部分描画のファイル内では form という変数名で使用するようになります。


h3. フォーム

new では html のフォームを使います。 *labelled_tabular_form_for* は Rails で通常使われる *form_for* メソッドをフォーム内のラベルとフィールドがテーブルのような配列されるように拡張したものです。引数は form_for と同じものを受け取ります。

第一引数はフォームの名前です。:foo を指定していますのでフォーム内で指定されるパラメータは params[:foo] のハッシュに格納されることになります。
第二引数はモデルクラスのオブジェクトを指定します。このオブジェクトの各メンバの値が対応するパラメータのフィールドデフォルト値となります。
第三引数はハッシュでアクションを指定します。コントローラを省略するとカレントのコントローラを指定したことになりました。同様にアクションを省略するとカレントのアクションになります。ここでは両方とも省略しているため、 自身の new アクションが指定されたことになります。
第四引数はオプションで省略しています。

ブロック内でフォームの各フィールドを設定します。各フィールドは f.submit ボタンのようにブロックの引数 @f@ のメソッドを使って設定します。


h3. フォーム内のパラメータ

app/views/foos/_form.index.html.erb の中身は次のようになります。これが new.html.erb の render の部分に入ることになります。
:locals のオプションで設定したようにこのファイル内では form が labelled_tabular_form_for のブロック変数でこれを使って、各フィールドを記述します。

<pre><code class="rhtml">
<%= error_messages_for 'foo' %>
<div class="box">
<p><%= form.text_field :subject,
                       :size => 100, :required => true %></p>
<p><%= form.text_area :description,
                      :class => 'wiki-edit' %></p>
<%= wikitoolbar_for 'foo_description' %>
</div>
</code></pre>

1 行目ではエラーメッセージの表示を指定しています。 foo という名前のフォーム内で入力にエラーがあった場合にエラーメッセージが表示されるようになっています。

*box* クラスのブロックは設定ダイアログのように背景を灰色にするためのものです。

この中で次のパラメータが配置されています。

|_. 対象 |_. パレメータ名 |_. フィールドタイプ |_. ラベル |
| 題名 | subject | テキストフィールド | field_subject |
| 説明 | description | テキストエリア | field_description |

ラベルが省略された場合、 *field_パラメータ名* というシンボルに対応するメッセージが使用されます。それぞれのメッセージは Redmine のメッセージファイルで定義されています。

subject のテキストフィールドのオプションではまずデフォルトでは幅が少し短いので :size で幅を指定しています。 次の :required オプションで true を指定しているので、必ず入力しなければならないことを表す  %{color:red}*% を付けています。ただし、これはマークを付けているだけでこのオプションで空文字の入力のエラー判定まで行ってくれるわけではありません。エラーチェックをする方法は次節で行います。

description では CSS の *wiki-edit* クラスとすることで wiki 編集用のスタイルのテキストエリアとしています。ただし、 wiki 編集用のツールボックスの出力は *wikitoolbar_for* メソッドです。この引数で foo フィールドの description のテキストエリアを指定しています。この 2 つの指定により説明のパラメータは wiki の入力ができることになります。



h2. モデルの実装

実際にパラメータの値が妥当かどうかの判定処理はモデルに記述します。

<pre><code class="ruby">
class Foo < ActiveRecord::Base
  unloadable

  validates_presence_of :subject
  validates_length_of :subject, :maximum => 255

end
</code></pre>

スケルトンで出力されたものに 4, 5 行目を追加しています。
4 行目の *validates_presence_of* で subject パラメータで未設定(空文字)を禁止しています。
5 行目で subject パラメータの文字数の最大値を指定しています。 subject は string 型なので、 255 文字の制限がありました。そのため 255 文字以上入力するとエラーとなるようにしています。


---

| [[プラグイン開発ガイド|^]] | [[GuideIndexAction|<<]] | [[GuideActionElse|>>]] |
